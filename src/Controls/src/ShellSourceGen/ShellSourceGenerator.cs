using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.Maui.Controls.ShellSourceGen;

[Generator(LanguageNames.CSharp)]
public class ShellSourceGenerator : IIncrementalGenerator
{
	const string AutoGeneratedHeaderText = """
		//------------------------------------------------------------------------------
		// <auto-generated>
		//     This code was generated by a .NET MAUI source generator.
		//
		//     Changes to this file may cause incorrect behavior and will be lost if
		//     the code is regenerated.
		// </auto-generated>
		//------------------------------------------------------------------------------
		""";

	const string QueryPropertyAttributeFullName = "Microsoft.Maui.Controls.QueryPropertyAttribute";

	const string QueryPropertyAttributeHelper = """
		#nullable enable
		namespace Microsoft.Maui.Controls
		{
			public static class QueryPropertyAttributeHelper
			{
				public static T GetValue<T>(IDictionary<string, object?> query, string queryId)
				{
					if (query.TryGetValue(queryId, out var obj))
					{
						if (obj is T t)
						{
							return t;
						}

						var convertedValue = Convert.ChangeType(obj, typeof(T));
						if (convertedValue is T t2)
						{
							return t2;
						}
					}

					return default!;
				}
			}
		}
		""";

	private record QueryAttributableToGenerate(INamedTypeSymbol ClassSymbol, QueryProperty[] Properties, Diagnostic[] Diagnostics);
	private record QueryProperty(string QueryId, IPropertySymbol Property);

	public void Initialize(IncrementalGeneratorInitializationContext initializationContext)
	{
		initializationContext.RegisterPostInitializationOutput(ctx =>
			ctx.AddSource("QueryPropertyAttributeHelper.g.cs", SourceText.From(QueryPropertyAttributeHelper, Encoding.UTF8)));

		IncrementalValuesProvider<QueryAttributableToGenerate?> classesToGenerate =
			initializationContext.SyntaxProvider
				.ForAttributeWithMetadataName(
					QueryPropertyAttributeFullName,
					predicate: static (s, _) => s is ClassDeclarationSyntax,
					transform: static (ctx, _) => GetQueryAttributableToGenerate(ctx))
				.Where(static m => m is not null);

		initializationContext.RegisterSourceOutput(classesToGenerate, GenerateQueryAttributablePartial);
	}

	private static void GenerateQueryAttributablePartial(SourceProductionContext sourceProductionContext, QueryAttributableToGenerate? attributable)
	{
		if (attributable is null)
		{
			return;
		}

		foreach (var diagnostic in attributable.Diagnostics)
		{
			sourceProductionContext.ReportDiagnostic(diagnostic);
		}

		var containingTypes = new Stack<string>();
		var containingType = attributable.ClassSymbol.ContainingType;

		// TODO this doesn't work well when some of the parent types is generic
		// we need to use similar strategy to https://andrewlock.net/creating-a-source-generator-part-5-finding-a-type-declarations-namespace-and-type-hierarchy/
		while (containingType is not null)
		{
			containingTypes.Push(containingType.Name);
			containingType = containingType.ContainingType;
		}

		var sourceBuilder = new StringBuilder();

		sourceBuilder.AppendLine(AutoGeneratedHeaderText);
		sourceBuilder.AppendLine("#nullable enable");
		sourceBuilder.AppendLine();

		if (!attributable.ClassSymbol.ContainingNamespace.IsGlobalNamespace)
		{
			sourceBuilder.AppendLine($"namespace {attributable.ClassSymbol.ContainingNamespace.ToDisplayString()};");
			sourceBuilder.AppendLine();
		}

		var indentation = "";
		while (containingTypes.Count > 0)
		{
			sourceBuilder.AppendLine($"{indentation}partial class {containingTypes.Pop()}");
			sourceBuilder.AppendLine($"{indentation}{{");
			indentation += "\t";
		}

		// TODO when the class is generic, we need to add type parameters here
		sourceBuilder.AppendLine($"{indentation}partial class {attributable.ClassSymbol.Name} : global::Microsoft.Maui.Controls.IQueryAttributable");
		sourceBuilder.AppendLine($"{indentation}{{");
		sourceBuilder.AppendLine($"{indentation}\tpublic void ApplyQueryAttributes(global::System.Collections.Generic.IDictionary<string, object?> query)");
		sourceBuilder.AppendLine($"{indentation}\t{{");

		foreach (var property in attributable.Properties)
		{
			sourceBuilder.AppendLine($"{indentation}\t\t{property.Property.Name} = global::Microsoft.Maui.Controls.QueryPropertyAttributeHelper.GetValue<{property.Property.Type}>(query, \"{property.QueryId}\");");
		}

		sourceBuilder.AppendLine($"{indentation}\t}}"); // end of ApplyQueryAttributes
		sourceBuilder.AppendLine($"{indentation}}}"); // end of class

		// close all nested types
		while (indentation.Length > 0)
		{
			indentation = indentation.Substring(1);
			sourceBuilder.AppendLine($"{indentation}}}");
		}

		sourceProductionContext.AddSource(
			$"{attributable.ClassSymbol.Name}.IQueryAttributable.g.cs",
			SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
	}

	private static bool ContainsIQueryAttributable(BaseListSyntax baseList)
		=> baseList.Types.Any(static baseTypeSyntax => IsIQueryAttributable(baseTypeSyntax.Type));

	private static bool IsIQueryAttributable(TypeSyntax identifierNameSyntax)
		=> identifierNameSyntax.ToString() == "IQueryAttributable" || identifierNameSyntax.ToString().EndsWith(".IQueryAttributable");

	private static QueryAttributableToGenerate? GetQueryAttributableToGenerate(GeneratorAttributeSyntaxContext context)
	{
		var semanticModel = context.SemanticModel;
		var classDeclarationSyntax = (ClassDeclarationSyntax)context.TargetNode;
		var classSymbol = (INamedTypeSymbol)context.TargetSymbol;

		// TODO: should we maybe check if the class already has an implementation of `ApplyQueryAttributes(IDictionary<object, string?>)` instead?
		if (classSymbol.AllInterfaces.Any(i => i.Name == "IQueryAttributable" && i.ContainingNamespace.Name == "Microsoft.Maui.Controls"))
		{
			// if the class already implements IQueryAttributable, skip it
			return null;
		}

		var properties = new List<QueryProperty>();
		var diagnostics = new List<Diagnostic>();

		foreach (AttributeData attribute in context.Attributes)
		{
			var queryId = attribute.ConstructorArguments[0].Value?.ToString();
			var propertyName = attribute.ConstructorArguments[1].Value?.ToString();

			if (queryId is null || propertyName is null)
			{
				// if the attribute is missing a parameter, we can't generate the code
				// TODO: report a diagnostic?
				continue;
			}

			var member = classSymbol.GetMembers().FirstOrDefault(m => m is IPropertySymbol prop && prop.Name == propertyName);
			if (member is not IPropertySymbol property)
			{
				diagnostics.Add(DiagnosticFactory.QueryPropertyDoesNotExist(attribute));
			}
			else if (property.SetMethod is null)
			{
				diagnostics.Add(DiagnosticFactory.QueryPropertyDoesNotHaveSetter(attribute));
			}
			else if (properties.Any(p => p.Property.Name == propertyName))
			{
				diagnostics.Add(DiagnosticFactory.QueryPropertyAlreadyUsed(attribute));
			}
			else
			{
				// only generate assignment for the property if the generated code would be valid
				// and if we're not overriding previous value
				properties.Add(new QueryProperty(queryId, property));
			}
		}

		return new QueryAttributableToGenerate(classSymbol, properties.ToArray(), diagnostics.ToArray());
	}
}
